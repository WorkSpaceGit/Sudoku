<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Судоку</title>

<link rel="icon" type="image/svg+xml" href='data:image/svg+xml;utf8,
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <style>text{font-family:monospace;font-size:8.5px;dominant-baseline:middle;text-anchor:middle;fill:%23eee;}</style>
  <text x="50%" y="22%">1|2|3</text>
  <text x="50%" y="50%">4|5|6</text>
  <text x="50%" y="78%">7|8|9</text>
</svg>'>
  
<style>
/* Щоб розміри працювали передбачувано */
*, *::before, *::after { box-sizing: border-box; }

:root {
  --grid-outer: 90vmin;
  --cell-size: calc(var(--grid-outer) / 9);
  --bg: #121212;
  --panel: #1e1e1e;
  --accent: #66f;
  --muted-border: #444;
  --strong-border: #888;
  --text: #eee;
  --error-bg: #A87761;
}
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--text);
  font-family: Arial, sans-serif;
}
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 12px;
}

/* Кнопки керування */
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}
button {
  background: #222;
  color: var(--text);
  border: 1px solid #555;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
}
button:hover { background: #333; }

/* Контейнер сітки — центруємо дочірні елементи */
.grid-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  max-width: var(--grid-outer);
  align-items: center; /* <-- ключова зміна */
  flex-grow: 1;
}

/* Обгортка сітки: задаємо явну ширину, що відповідає 9 клітинкам */
.grid-wrap {
  display: flex;
  justify-content: center;
  align-items: center;
  width: calc(var(--cell-size) * 9);
  max-width: 100%;
}

/* Таблиця: також фіксована ширина, щоб точно співпадати з панеллю чисел */
table#sudoku-grid {
  border-collapse: collapse;
  user-select: none;
  width: calc(var(--cell-size) * 9); /* явна ширина */
  max-width: 100%;
}
td {
  width: var(--cell-size);
  height: var(--cell-size);
  border: 1px solid var(--muted-border);
  background: var(--panel);
}
tr:nth-child(3n) td { border-bottom: 3px solid var(--strong-border); }
td:nth-child(3n) { border-right: 3px solid var(--strong-border); }
tr:first-child td { border-top: 3px solid var(--strong-border); }
td:first-child { border-left: 3px solid var(--strong-border); }
td.prefilled { font-weight: 700; color: #aaf; }
td.error input { background: var(--error-bg); color: #fff; }

input {
  width: 100%;
  height: 100%;
  border: 0;
  background: transparent;
  color: var(--text);
  font-size: calc(var(--cell-size)*0.55);
  text-align: center;
  font-family: monospace;
  outline: none;
}
input:focus { outline: none; }

/* Панель чисел */
.number-panel {
  display: flex;
  justify-content: center;
  padding: 4px;
  width: 100%;
}

/* Головна зміна: ширина рядка цифр тепер точно така ж, як сітка */
.numbers-row {
  display: grid;
  grid-template-columns: repeat(10, 1fr); /* 9 цифр + ластик */
  gap: 6px;
  width: calc(var(--cell-size) * 9); /* вирівнювання з таблицею */
  max-width: 100%;
}

.number-panel button {
  aspect-ratio: 1/1;
  border: none;
  border-radius: 8px;
  background: var(--panel);
  color: var(--text);
  font-size: calc(var(--cell-size)*0.45);
  cursor: pointer;
  transition: background 0.2s;
  width: 100%;
}
.number-panel button:hover { background: rgba(102,102,255,0.2); }
.number-panel button.active {
  background: var(--accent);
  color: white;
}

/* Невеликі підлаштування для дуже вузьких екранів */
@media (max-width: 420px) {
  :root { --grid-outer: 95vmin; } /* злегка більше для вузьких екранів */
  .numbers-row { gap: 4px; }
  .number-panel button { font-size: calc(var(--cell-size)*0.38); }
  input { font-size: calc(var(--cell-size)*0.5); }
}
</style>
</head>
<body>

<div class="controls">
  <button id="btn-easy">Простий</button>
  <button id="btn-medium">Нормальний</button>
  <button id="btn-hard">Складний</button>
  <button id="btn-new">Нова гра</button>
  <button id="btn-show-solution">Показати розв’язок</button>
</div>

<div class="grid-container">
  <div class="grid-wrap">
    <table id="sudoku-grid"></table>
  </div>

  <div class="number-panel">
    <div class="numbers-row">
      <button data-num="1">1</button>
      <button data-num="2">2</button>
      <button data-num="3">3</button>
      <button data-num="4">4</button>
      <button data-num="5">5</button>
      <button data-num="6">6</button>
      <button data-num="7">7</button>
      <button data-num="8">8</button>
      <button data-num="9">9</button>
      <button data-num="del">⌫</button>
    </div>
  </div>
</div>

<div id="status" style="visibility:hidden">Готово</div>

<script>
/* Твій JS залишився без змін — він працює з DOM як раніше.
   Я просто переніс/скопіював оптимізовану версію JS з попереднього файлу. */

class SudokuGame {
  constructor() {
    this.SIZE = 9;
    this.grid = Array.from({ length: this.SIZE }, () => Array(this.SIZE).fill(0));
    this.solution = null;
    this.puzzle = null;
    this.currentLevel = 'easy';
    this.showingSolution = false;
    this.activeInput = null;
    this.selectedNumber = null;
    this.initializeDOM();
    this.attachEvents();
    this.validator = new SudokuValidator(this);
    this.generator = new PuzzleGenerator(this);
    this.numberPanel = new NumberPanel(this);
    this.startGame('easy');
  }

  initializeDOM() {
    this.dom = {
      table: document.getElementById('sudoku-grid'),
      cells: [],
      inputs: [],
      status: document.getElementById('status'),
      numberButtons: []
    };
    this.createGrid();
  }

  createGrid() {
    const table = this.dom.table;
    table.innerHTML = '';
    for (let r = 0; r < this.SIZE; r++) {
      const tr = document.createElement('tr');
      for (let c = 0; c < this.SIZE; c++) {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.inputMode = 'none';
        input.maxLength = 1;
        td.appendChild(input);
        tr.appendChild(td);
      }
      table.appendChild(tr);
    }
    this.dom.cells = Array.from(table.querySelectorAll('td'));
    this.dom.inputs = Array.from(table.querySelectorAll('input'));
  }

  attachEvents() {
    document.getElementById('btn-easy').onclick = () => this.startGame('easy');
    document.getElementById('btn-medium').onclick = () => this.startGame('medium');
    document.getElementById('btn-hard').onclick = () => this.startGame('hard');
    document.getElementById('btn-new').onclick = () => this.startGame(this.currentLevel);
    document.getElementById('btn-show-solution').onclick = () => this.toggleSolution();
    this.dom.inputs.forEach(inp => {
      inp.addEventListener('click', () => {
        if (this.showingSolution || inp.disabled) return;
        if (this.selectedNumber === 'del') {
          inp.value = '';
          this.validator.checkErrors();
          return;
        }
        if (this.selectedNumber) {
          inp.value = this.selectedNumber;
          this.validator.checkErrors();
        }
      });
      inp.addEventListener('focus', e => e.target.blur());
    });
  }

  async startGame(level) {
    this.currentLevel = level;
    this.dom.status.textContent = 'Генерація...';
    await new Promise(r => setTimeout(r, 10));
    const full = this.generator.generateFullSolution();
    const open = this.generator.getOpenCount(level);
    const ensureRowCol = level === 'easy';
    const puzzle = this.generator.makePuzzleFromSolution(full, open, ensureRowCol);
    this.solution = full;
    this.puzzle = puzzle;
    this.displayPuzzle(puzzle);
    this.showingSolution = false;
    document.getElementById('btn-show-solution').textContent = 'Показати розв’язок';
    this.dom.status.textContent = 'Готово';
  }

  displayPuzzle(puzzle) {
    this.dom.inputs.forEach((inp, i) => {
      const r = Math.floor(i / this.SIZE);
      const c = i % this.SIZE;
      const v = puzzle[r][c];
      const cell = this.dom.cells[i];
      if (v !== 0) {
        inp.value = v;
        inp.disabled = true;
        cell.classList.add('prefilled');
      } else {
        inp.value = '';
        inp.disabled = false;
        cell.classList.remove('prefilled');
      }
    });
    this.validator.checkErrors();
  }

  toggleSolution() {
    if (!this.solution || !this.puzzle) return alert('Спочатку створіть головоломку!');
    if (!this.showingSolution) {
      this.dom.inputs.forEach((inp, i) => {
        const r = Math.floor(i / this.SIZE);
        const c = i % this.SIZE;
        inp.value = this.solution[r][c];
        inp.disabled = true;
      });
      this.showingSolution = true;
      document.getElementById('btn-show-solution').textContent = 'Сховати розв’язок';
    } else {
      this.displayPuzzle(this.puzzle);
      this.showingSolution = false;
      document.getElementById('btn-show-solution').textContent = 'Показати розв’язок';
    }
  }
}

/* Validator / Generator / NumberPanel (без змін по логіці) */
class SudokuValidator {
  constructor(game) { this.game = game; }
  checkErrors() {
    const SIZE = this.game.SIZE;
    const b = this.getBoardState();
    const e = new Set();
    for (let r = 0; r < SIZE; r++) {
      const s = new Map();
      for (let c = 0; c < SIZE; c++) {
        const v = b[r][c];
        if (!v) continue;
        if (s.has(v)) { e.add(`${r},${c}`); e.add(`${r},${s.get(v)}`); }
        else s.set(v, c);
      }
    }
    for (let c = 0; c < SIZE; c++) {
      const s = new Map();
      for (let r = 0; r < SIZE; r++) {
        const v = b[r][c];
        if (!v) continue;
        if (s.has(v)) { e.add(`${r},${c}`); e.add(`${s.get(v)},${c}`); }
        else s.set(v, r);
      }
    }
    for (let br = 0; br < 3; br++) {
      for (let bc = 0; bc < 3; bc++) {
        const s = new Map();
        for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) {
          const r = br*3+i, c = bc*3+j, v = b[r][c];
          if (!v) continue;
          if (s.has(v)) { e.add(`${r},${c}`); const [rr,cc] = s.get(v); e.add(`${rr},${cc}`); }
          else s.set(v, [r,c]);
        }
      }
    }
    this.game.dom.cells.forEach((cell, idx) => {
      const r = Math.floor(idx / SIZE), c = idx % SIZE;
      cell.classList.toggle('error', e.has(`${r},${c}`));
    });
  }
  getBoardState() {
    const SIZE = this.game.SIZE;
    const b = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    this.game.dom.inputs.forEach((inp, i) => {
      const v = parseInt(inp.value) || 0;
      b[Math.floor(i / SIZE)][i % SIZE] = v;
    });
    return b;
  }
}

class PuzzleGenerator {
  constructor(game) { this.game = game; }
  generateFullSolution() {
    const SIZE = this.game.SIZE;
    const b = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    const nums = () => [1,2,3,4,5,6,7,8,9].sort(() => Math.random() - 0.5);
    const isSafe = (b, r, c, n) => {
      for (let i=0;i<SIZE;i++) if (b[r][i]===n || b[i][c]===n) return false;
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let i=0;i<3;i++) for (let j=0;j<3;j++) if (b[br+i][bc+j]===n) return false;
      return true;
    };
    const back = (p=0) => {
      if (p === SIZE*SIZE) return true;
      const r = Math.floor(p/SIZE), c = p%SIZE;
      for (const n of nums()) {
        if (isSafe(b,r,c,n)) {
          b[r][c] = n;
          if (back(p+1)) return true;
          b[r][c] = 0;
        }
      }
      return false;
    };
    back();
    return b;
  }

  countSolutions(board, limit=2) {
    let solutions = 0;
    const SIZE = this.game.SIZE;
    const isSafe = (b,r,c,n) => {
      for (let i=0;i<SIZE;i++) if(b[r][i]===n||b[i][c]===n) return false;
      const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
      for (let i=0;i<3;i++) for (let j=0;j<3;j++) if (b[br+i][bc+j]===n) return false;
      return true;
    };
    function findEmpty(b){ for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (b[r][c]===0) return [r,c]; return null; }
    function back(b) {
      if (solutions>=limit) return;
      const pos = findEmpty(b); if (!pos) { solutions++; return; }
      const [r,c] = pos;
      for (let n=1;n<=9;n++) { if (isSafe(b,r,c,n)) { b[r][c]=n; back(b); b[r][c]=0; if (solutions>=limit) return; } }
    }
    const copy = board.map(r=>r.slice()); back(copy); return solutions;
  }

  getOpenCount(level) {
    const total = this.game.SIZE * this.game.SIZE;
    if(level==='easy') return Math.round(total * 0.7);
    if(level==='medium') return Math.round(total * 0.5);
    if(level==='hard') return Math.round(total * 0.3);
    return Math.round(total * 0.5);
  }

  makePuzzleFromSolution(full, openCount, ensureRowCol=false) {
    const SIZE = this.game.SIZE;
    const puzzle = full.map(r => r.slice());
    const allCells = [];
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) allCells.push([r,c]);
    allCells.sort(()=>Math.random()-0.5);
    let removed = 0;
    const maxRemovals = SIZE*SIZE - openCount;
    for (const [r,c] of allCells) {
      if (removed>=maxRemovals) break;
      const backup = puzzle[r][c]; puzzle[r][c] = 0;
      if (this.countSolutions(puzzle,2) === 1) { removed++; } else puzzle[r][c] = backup;
    }
    if (ensureRowCol) {
      for (let i=0;i<SIZE;i++) {
        if (puzzle[i].every(v=>v===0)) {
          const c = Math.floor(Math.random()*SIZE); puzzle[i][c] = full[i][c];
        }
        const colEmpty = puzzle.every(r=>r[i]===0);
        if (colEmpty) {
          const r = Math.floor(Math.random()*SIZE); puzzle[r][i] = full[r][i];
        }
      }
    }
    return puzzle;
  }
}

class NumberPanel {
  constructor(game) {
    this.game = game;
    this.buttons = new Map();
    this.initialize();
  }

  initialize() {
    const container = document.querySelector('.number-panel');
    this.buttons = Array.from(container.querySelectorAll('button')).reduce((map, button) => {
      map.set(button.dataset.num, button);
      return map;
    }, new Map());
    this.buttons.forEach((button, number) => {
      button.addEventListener('click', () => this.handleNumberClick(number));
    });
  }

  handleNumberClick(number) {
    const same = this.game.selectedNumber === number;
    this.game.selectedNumber = same ? null : number;
    this.updateActiveNumber();
  }

  updateActiveNumber() {
    this.buttons.forEach((button, num) => {
      button.classList.toggle('active', num === this.game.selectedNumber);
    });
  }
}

/* Запуск гри */
document.addEventListener('DOMContentLoaded', () => {
  new SudokuGame();
});
</script>
</body>
</html>
